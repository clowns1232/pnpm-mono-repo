# 마이크로 프론트엔드란?

# 1. 특징

프론트엔드가 점점 커지면서 이를 효율적으로 다뤄야 할 필요가 생겼는데
이를 마이크로 서비스처럼 전체 화면을 작동할 수 있는 단위로 나누어 개발한 후 서로 조립하는 방식을 말합니다.

방법은 크게 멀티레포, 모노레포로 나뉘고
기존 방식인 하나의 레포지티에 나누지 않고 개발하는걸 모놀리식라 합니다.

# 2. 모놀리식이란?

## 2.1 모놀리식

- 장점
  - 단순성 : 모든 코드가 단일 코드 베이스이기 때문에 로컬에서 실행 시 단일 애플리케이션만 실행하면 됩니다.
  - 간편한 배포 : 단일 프로젝트를 배포하면 되기 때문에 간편합니다.
  - 디버깅과 테스트가 쉬움 : 모든 코드가 단일 프로젝트에 있기 때문에 디버깅 및 테스트가 쉬움
  - 쉬운 모니터링 : 코드가 단일 프로젝트에 존재하기 때문에 오류가 발생한 위치를 찾기 쉽습니다.
- 단점
  - 규모가 커지면 유지 보수가 어려워짐
  - 유연하지 않는 확장성 : 모놀리식도 확장은 가능하지만 특정 단위로 확장은 불가능하고 전체 프로젝트 단위로 확장해야 합니다.
  - 대규모 팀 작업이 어려움 : 모든 팀이 동일한 코드, 동일한 프로젝트에서 작업하기 때문에 코드의 충돌 가능성이 높고 이에 따른 다른 개발자의 작업에 영향을 줄 수 있습니다.
  - 기술 사용 제한 : 기존 프로젝트를 다른 기술로 변환하기 어렵기 때문에 일반적으로 프로젝트를 구성하면 오랫동안 동일한 기술을 사용합니다.
  - 느린 배포 속도 : 하나의 레포지티에서 배포하므로 속도가 느려집니다.

그렇다면 언제 모놀리식을 사용할까요?

- 규모가 작은 애플리케이션의 경우
- 현 비즈니스를 성장할 계획이 없거나, 복잡한 시스템이 없고 관리가 필요하지 않을 경우
- 아직 아이디어 구상 단계일 경우
- 팀의 규모가 작거나 신생 팀일 경우와 새로운 도메인을 시작할 때
- **MVP(최소 기능 제품)**일 경우는 모놀리식이 피드백을 빠르게 수집이 가능합니다.
- 주된 작업이 CRUD일 경우

# 3. 모놀리식에서 마이크로서비스, 마이크로 프론트엔드 까지

- 마이크로서비스는 애플리케이션을 도메인을 기준으로 모놀리식한 백엔드의 서비스를 분리하는 것을 의미합니다. 마이크로 프론트엔드는 이 개념을 프론트엔드 세계로 확장한 것입니다.
- 마이크로프론트엔드는 웹 어플리케이션을 서로 다른 모듈 및 개별 기능으로 분할하고 조합하는 아키텍처이며 백엔드의 마이크로 서비스의 이점인 유연성과 보다 높은 개발 생산성을 가집니다.

![아키텍쳐 확장 순서](./image/아키텍쳐%20확장%20순서.png)

# 4. 멀티레포 vs 모노레포

마이크로프론트엔드를 구현하는 구조에는 멀티레포와 모노레포가 있습니다.

![mult and mono](./image/mult%20and%20mono.png)

- 멀티레포 → 레포지티를 여러개로 나눠서 관리하는 방법
  - 장점
    - 레포지티 별 담당자를 지정
      - 수월한 패키지 관리
    - 레포지티의 빠른 CI Build
      - 기능을 레포지티 별로 나눠서 개발 하므로 레포지티 크기가 작아짐
    - 패키지의 명확한 분리로 인한 유연성 향상
      - 레포지티 상 서로 연계 관계가 없기 때문에 추가, 수정, 유지 관리 편리
  - 단점
    - 중복된 설정 및 반복된 설치
      - 모든 공통된 설정과 모듈들을 반복적으로 설정/설치해야 함
    - 코드 재사용이 쉽지 않으므로 중복 코드 가능성이 높아짐
      - 다른 레포지티 코드를 사용하기 위해서 추가 작업이 필요
    - 이슈의 분산
      - 각 다른 레포지토리가 연관되어있는 이슈 트래킹 관리 어려움
    - 디펜던시 헬
      - 프로젝트가 커지면 많은 레포지티가 생기고 그에 따른 다양한 의존관계가 생겨서 복잡해짐
      - 여러 패키지들이 사용하는 같은 모듈에서 버전 차이 발생 및 충돌 발생 가능
- 모노레포 → 레포지티 하나에서 나눠서 관리하는 방법(멀티레포의 장점은 단점으로 단점은 장점으로 변한다.)
  - 장점
    - 공통 항목 단일화
      - eslint, Build, Unit Test 등 공통된 설정 및 필요한 node module을 한 번의 설치와 한 번의 설정으로 모든 패키지가 사용할 수 있다.
    - 쉬운 코드 공유
    - 단일 이슈 트래킹
      - 모노레포 내 연관된 패키지들에 관한 (분산될 필요 없는) 이슈 트래킹
    - 효율적인 의존성 관리
  - 단점
    - Repository의 거대화
      - 분산되어 있던 모든 리소스를 하나의 레포로 합치면서 생기는 문제
    - 느린 CI Build
      - CI가 하나로 구성된다는 장점 == 규모가 커짐에 따라 분산된 CI 빌드보다 속도가 느릴 수밖에 없음
    - 무분별한 의존성
      - Package 간 의존성 관리가 쉽지만, 오히려 과도한 의존성 관계 발생 가능
